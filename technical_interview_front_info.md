#Front_End 면접준비

##JSP(JavaServer Pages)
HTML 코드에 JAVA 코드를 넣어 동적우베페이지를 생성하는 웹어플리케이션 도구이다.
JSP가 실행되면 자바 서블릿(Servlet)으로 변환되고 클래스로 컴파일된 후 응답하게 된다. 이변환 과정에서 _jspService()메서드가 생성되는데, 변환된 코드의 위치는 스크립트 요소에 따라 메서드 내부 혹은 외부에 놓인다.
웹 어플리케이션 서버에서 동작되며 필요한 기능을 수행하고 그렇게 생성된 데이터를  웹페이지와 함께 클라이언트로 응답한다.
한번 서블릿으로 컴파일된JSP 파일은 캐시됨으로 실질적 성능 저하 없이 사용가능하다
클라이언트 단은 JSP로 서버 단은 서블릿 요소가 주로 사용된다.

JSP과 Servlet
JSP는 HTML 내부에 JAVA소스가 들어감으로인해 HTML 코드를 작성하기 간편하다.
Servlet은 자바코드내에 HTML 코드가 있어서 읽고 쓰기가 굉장히 불편하다.

JSP의 구조
지시어(Directive)
스크립트 요소(Script Element)
    1.선언부(Declaration)<%! 선언부 %> _jspService() 외부
    2.스크립틀릿(Scriptlet)<% 스크립틀릿 %>_jspService() 내부
    3.표현식(Expression)<%= 표현식 내용 %>

지시어
JSP를 Sevlet으로 변환하는데 필요한 정보를 JSP 엔진에게 알려주는 부분
주로 스크립트 언어나 인코딩 방식 등을 설정한다.
page: JSP 페이지에 대한 정보를 설정하는 지시어(<%@ page 속성명 = "값" %>
include: 외부 파일을 현재 JSP 파일에 포함시키는 지시어(<%@ page file="경로" %>
taglib: 표현 언어에서 사용할 자바 클래스나 JSTl을 선언하는 지시어


이벤트 루프
CALL STACK -> WEB API -> QUEUE -> EVENTLOOP -> CALL STACK

CALLBACK QUEUE의 종류로는 TASK QUEUE, MICROTASK QUEUE 가 있다.
MICROTASTK QUEUE는 그 어떤 곳 보다 가장 먼저 우선으로 콜백이 처리되게 된다.

DB
인덱스
데이터베이스에서 테이블의 검색 속도를 높이기 위한 기술 또는 장치
B트리,B+트리나 해시 테이블 구조를 사용하기 때문에 검색 속도를 높이기 위한 자료구조라고도 표현한다.
인덱스는 키와 값으로 구성된다.
키는 검색에 사용되는 컬럼이나 컬럼 조합이다
값은 해당 레코드를 가리키는 포인터 이다.
장점
인덱스를 사용하면 검색 작업이 빨라진다.
데이터베이스에서 데이터를 검색할 때
, 인덱스를 사용하면 검색 대상이 줄어들어 빠르게 결과를 가져올 수 있다.
중복데이터 제거
인덱스는 중복 데이터를 제거하는 데에도 사용할 수 있다.
인덱스를 사용하면 중복 데이터를 허용하지 않도록 강제할 수 있다.
데이터 정렬
인덱스는 데이터를 정렬하는 데에도 사용된다.
데이터베이스에서 데이터를 정렬할 떄 인덱스를 사용하면 정렬이 빠르고 효율적이다.

단점
생성시간의 소요, 인덱스를 만드는데 시간이 걸린다.
데이터 공간 차지, 데이터베이스의 크기에 따라 시간이 많이 걸릴 수 있다.
인덱스를 저장하려면 따로 공간을 할당해야 한다. 약 10%
추가적인 작업의 필요성, 데이터베이스에서 데이터가 변경될 때다 인덱스도 함께 변경해야 한다.(INSERT,DELETE,UPDATE)
CUD가 빈번한 속성에 인덱스를 걸게 되면 사용하지 않음 처리로 인해
인덱스의 크기가 비대해져서 성능은 오히려 저하되는 역효과가 발생할 수 있다.

해시테이블은 해시 함수를 이용하여 키 값을 배열의 인덱스로 변환하고,이 인덱스에 해당하는 배열의 원소에 값을 저장한다.
키 값의 해시값을 계산한 뒤, 해당 해시값을 인덱스로 이용한다.
서로다른 키 값이 같은 해시값을 반환하여 같은 배열 인덱스에 데이터를 저장하게 되는 상황을 해시 충돌이라고 한다.
해시충돌을 처리하는 방법으로는 체이닝과 개방주소법 이 있다.
체이닝은 해시 충돌이 발생하면 해당 인덱스에 연결 리스트를 생성하여, 동일한 인덱스에 속한 다른 데이터와 함께 연결리스트에 추가하는 방법이다.
개방주소법은 해시 충돌이 발생하면 다른 빈 인덱스르르 탐색하여 데이터를 저장하는 방법이다.
해시테이블은 등호 연산에 최적화 되어있다.
DB에서는 부등호 연산이 자주 사용되어 주로 사용하지 않는다.

B트리는
인덱스 노드에 접근한다.
인덱스 노드를 검색하여 검색 키와 일치하는 서브 트리를 선택한다.
선택된 서브 트리에서 다시 검색을 수행한다.
검색 키와 일치하는 데이터 페이지를 찾으면 검색을 종료한다.

B+트리는 B트리의 키 값과 데이터 값이 노드 안에 함께 저장되기 때문에 노드 크기가 크로,
디스크 I/O 작업이 많아지는 문제를 해결하기 위하여 고안되었다.
B+ 트리는 데이터 노드의 포인터만을 갖고, 모든 데이터는 리프 노드에만 저장하게 된다.
B+ 트리는 항상 마지막 리프노드 까지 조회해야 하기 때문에 logN의 시간복잡도를 가진다.

복합인덱스
B트리로 구성된다.
두 개 이상의 컬럼을 포함하는 인덱스이다.
인덱스를 사용하여 데이터를 검색할 때, 인덱스의 첫번째 컬럼부터 순차적으로 검색하기 때문에 컬럼의 순서가 쿼리의 성능에 큰 영향을 미친다.
가장 자주 검색되거나 필터링 되는 컬럼을 인덱스의 첫번째 컬럼으로 설정하는 것이 좋다
인덱스를 통한 데이터 검색 속도를 최대화 할 수 있다.
Join연산이나 복잡한 쿼리에서 큰 효과를 발휘한다.
Where절에 있는 컬럼들을 기준으로 생성하는 것이 효과적이다.
복합 인덱스를 통해 여러 테이블의 데이터를 빠르게 결합하고, 필요한 데이터만을 효율적으로 추출할수 있다.

트랜잭션
데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 혹은 일련의 연산들을 말한다.

1.원자성
트랜잭션의 연산은 데이터베이스에 전부 반영이 되거나 번부 반영이 되지 않아야 한다.
2.일관성
시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태같아야 한다.
3.독립성
수행중인 트랙잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.
4.영속성
완료된 트랜잭션의 결과는 영구적으로 반영되어야한다.

Commit
한개의 트랜잭션에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.

Rollback
하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소 하는 연산이다.


정규화
이상현상이 있는 릴레이션을 분해하여 이상현상을 없애는 과정이다.
이상현상이 존재하는 릴레이션을 분해하여 여러 개의 릴레이션을 생성하게 된다.
정규형이 높을 수록 이상현상은 줄어들게 된다.
테이블 간 중복된 데이터를 허용하지 않는 것이며 무결성을 유지하고 DB 저장 용량을 줄일 수 있다.

이상현상
1.삽입 이상
자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 현상
2.갱신 이상
중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상
3.삭제 이상
어떤 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되어버리는 현상

제1정규화
테이블의 컬럼이 원자값을 갖도록 테이블을 분해하는 것이다.
각 컬럼은 하나의 속성만 가진다, 하나의 컬럼은 같은 종류나 타입값을 가진다.
각 컬럼이 유일한 이름을 가진다. 컬럼의 순서가 상관 없어야 한다.
제2정규화
제1정규화를 만족해야한다.
모든 컬럼이 부분적 종속이 없어야 하며 완전 함수 종속을 만족해야 한다.
제3정규화
제2정규화를 만족해야한다.
기본키를 제외한 속성들 간의 이행 종속성이 없어야한다.
BCNF
제3정규화를 만족해야한다.
모든 결정자가 후보키 집합에 속해야 한다.

HTTPS란
OSI7 계층         TCP/IP             
1.Application       Application                    HTTP FTP SMTP
2.Presentation     ""                                   DNS RIP SNMP
3.Session             ""
4.Transport          Transport                      TCP UDP
5.Network            Internet                        ARR IP IGMP ICMP
6.Data-Link          NetworkAccess
7.Physical                                                    Ethernet TokenRing FramRelay ATM

TCP
인터넷상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜
애플리케이션에게 신뢰적이고 연결지향성 서비스를 제공한다.
TCP와 IP는 함께 사용되며 IP는 배달을, TCP는 패킷의 추적 및 관리를 하게된다.

3-way handshaking 과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.
흐름 제어 및 혼잡 제어.
높은 신뢰성을 보장한다.
UDP보다 속도가 느리다.
전이중(Full-Duplex), 점대점(PointtoPoint)방식

UDP
데이터를 독립적인 관계를 지니는 패킷(데이터그램)으로 처리하는 프로토콜
비연결형 프로토콜으로 할당되는 논리적인 경로가 없고 각각의 패킷이 다른 경로로 전송되며 이 각각의 패킷은 독립적인 관계를 지니게 된다.
연결을 설정하고 해제하는 과정이 존재하지 않는다.
연속성이 중요한 실시간 서비스(스트리밍)에 좋다.

비연결형 서비스로 데이터그램 방식을 제공한다.
정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
신뢰성이 낮다
TCP보다 속도가 빠르다

CheckSum
중복 검사의 한 형태로 송신된 자료의 무결성을 보호하는 단순한 방법이다.
통신에서 CRC 즉 순환 중복 검사를 체크섬이라 한다.

단순 합계 체크섬
가장 간단한 형태의 체크섬, 데이터의 모든 바이트를 더한 후 그 결과를 사용
단순하고 빠르지만, 간단한 오류만 검출
사용되는 데이터 값은 프로토콜 별로 다르며
데이터를 모두 더한 값을 이진수로 나타내어 2의 보수를 취한 뒤 1을 더한다
기존 데이터와 합산하여 값이 0이면 오류가 없다는 뜻이다.

오버플로우 회피
단순 합계 체크섬에서 발생할 수 있는 오버플로우를 회피하기 위해 추가적인 조치를 취한것
캐리 니블을 버리는 방식으로 최상위 4bit를 버리고 단순 합계 체크섬과 동일한 동작을 취한다.

CORS(Cross-Origin Resource Sharing)
보안정책 SOP(같은 출처만 리소스를 공유할 수 있다)을 지키기위한 정책이다.
교차 출처 리소스 공유는 브라우저가 자신의 출처가 아닌 다른 어떤 출처(도메인, 스킴 혹 포트)로부터 자원을 로딩하는 것을 허용하도록 서버가 허가 해주는 HTTP 헤더 반 메커니즘 이다.
브라우저 단에서 구현된 정책으로 브라우저를 통하지 않은 서버 간 통신에선 정상 작동한다.

일반적인 요청에 대해서는 CORS 정책검사를 하지 않는다
1. 요청 메소드가 GET,HEAD,POST 인경우
2. Request Header 속성이 Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width
3. Content-Type 속성이 application/x-www-form-urlencoded, multipart/form-data, text/plain
4. 요청에 사용된 XMLHttpRequestUpload 객체에 이벤트 리스너가 등록되어 있지않는 경우
5. 요청에 ReadableStream 객체가 사용되지 않는 경우

Preflight Request
예비 요청과 본 요청으로나누어서 서버로 전송하는 요청방식
예비 요청에는 HTTP메소드 중 OPTIONS 메소드가 사용된다.
브라우저 스스로  요청을 보내는 것이 안전한지 확인하는 것
많은 리소스가 사용된다
Max-Age 헤더 정보를 통해 캐싱하여 효율을 높일 수 있다.
응답은 무조건 200 이여야 한다.

아래 response header 를 설정하여 CORS 정책을 지킬 수 있다.
Access-Control-Allow-Origin : 허가된 Origin
Access-Control-Allow-Methods : 허가된 메소드
Access-Control-Allow-Headers : 허가된 헤더
Access-Control-Max-Age : 응답 캐시가 유효 시간
 
Credential Request
헤더에 인증과 관련된 정보(쿠키, 토큰 등)를 담아서 보내는 방법이다.
다른출처 간 통신에서 좀 더 보안을 강화하고 싶을 때 사용한다.

fetch API, Axios, Ajax 등 서버로 쿠키를 함께 전송해야 하는 경우
요청에 쿠키가 담기게 되면 Credential Request 허용이 되어 있어야한다.
CORS 처리를 위한 Filter는 반드시 인증을 처리하는 Filter 이전에 있어야 한다.

same-origin (기본값)	같은 출처 간 요청에만 인증 정보를 담을 수 있다
include	모든 요청에 인증 정보를 담을 수 있다
omit	모든 요청에 인증 정보를 담지 않는다

omit 가 아닌 옵션을 사용하여 리소스 요청에  인증정보가 포함 된다면,
Acees-Control-Allow-Origin 는 *(와일드카드)를 사용할 수 없으며 명시적 URL이여야한다.
Access-Control-Allow-Credentials: true 헤더 정보가 들어가야 한다.

CSRF 
해당 사이트의 서버를 타켓
사용자가 자신의 의지와는 무관하게 침입자가 의도한 행위를 서버에 요청하게 만드는 공격

CSRF가 성공하귀 위한 3가지 조건
1. 사용자는 보안이 취약한 서버로부터 이미 로그인되어 있는 상태
2. 쿠키 기반의 서버 세션 정보를 획득할 수 있다.
3. 요청 방법에 대한 파악, 예상하지 못한 요청 매개변수가 없어야함.

방어방법
1.Referer check (리퍼러 체크)
2.CAPTCHA 도입
3.CSRF 토큰사용

XSS
클라이언트의 브라우저를 타켓
웹사이트에서 의도치 않은 스크립트를 넣어서 실행시키는 기법

XSS가 성공하귀 위한 3가지 조건
1. 취약점을 찾아 세션 쿠키를 탈취하는 스크립트를 사이트에 삽입
2. 사용자가 웹 사이트에 접근할때 마다 스크립트가 작동
3. 작동된 스크립트를 통해 사용자의 세션 쿠키를 탈취

방어방법
중요 정보는 쿠키 대신 서버에 저장한다.
정보를 암호화한다.
httpOnly 옵션을 설정한다 (document.cookie를 이용해 쿠키에 직접 접근하는 것을 방지)
Url encoding이나 문자열을 치환한다.
![XSS 와 CSRF 비교](https://github.com/user-attachments/assets/9565dee9-d82f-4c84-8877-ebe126f30ef1)

